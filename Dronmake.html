
<!DOCTYPE html>
<html>
  <head>
    <title>Hello, World!</title>
    <style>
body {
  font-family: Arial, sans-serif;
  background: #f7f7f7;
  margin: 30px;
  color: #222;
}

h1 {
  color: #3178c6;
  margin-bottom: 10px;
}

p, p1 {
  font-size: 16px;
  line-height: 1.6;
  display: block;
  margin-bottom: 18px;
}

code, pre {
  background: #272822;
  color: #f8f8f2;
  padding: 8px 12px;
  border-radius: 5px;
  font-family: 'Fira Mono', 'Consolas', monospace;
  font-size: 15px;
  white-space: pre-wrap;
  word-break: break-all;
  display: block;
  margin-bottom: 15px;
}

img {
  border: 2px solid #ccc;
  border-radius: 7px;
  margin: 18px 0;
  box-shadow: 2px 4px 15px #aaa;
}

/* Optional: For code in HTML with <br> instead of <pre> */
p1 {
  background: #272822;
  color: #f8f8f2;
  padding: 12px;
  border-radius: 5px;
  font-family: 'Fira Mono', 'Consolas', monospace;
  font-size: 15px;
  white-space: pre-line;
  word-break: break-all;
}

@media (max-width: 600px) {
  body {
    margin: 10px;
    font-size: 14px;
  }
  img {
    width: 100% !important;
    height: auto !important;
  }
}
    </style>
    
  </head>
  <body>
    <h1>rf24 library function</h1>
    <p1>
rf24 लाइब्रेरी, जो कि nRF24L01 वायरलेस मॉड्यूल के साथ उपयोग के लिए है, TMRH20 द्वारा लिखी गई है। यह लाइब्रेरी Arduino IDE में उपयोग की जाती है और इसमें मॉड्यूल के साथ इंटरैक्ट करने के लिए पूर्वनिर्धारित फ़ंक्शन शामिल हैं। 
rf24 लाइब्रेरी का उपयोग कैसे करें:
1. Arduino IDE में लाइब्रेरी स्थापित करें:
Arduino IDE खोलें, Sketch > Include Library > Add. ZIP Library पर जाएँ और फिर rf24 लाइब्रेरी की ZIP फ़ाइल चुनें। Arduino Project Hub के अनुसार 
2. उदाहरण कोड (examples) का उपयोग करें:
rf24 लाइब्रेरी में उदाहरणों का एक फ़ोल्डर होता है, जिसमें nRF24L01 मॉड्यूल के साथ उपयोग के लिए कोड शामिल हैं। 
3. विस्तृत जानकारी के लिए, rf24 लाइब्रेरी की documentation देखें:
YouTube पर एक वीडियो में बताया गया है कि लाइब्रेरी को विस्तृत जानकारी के लिए संदर्भित किया जाना चाहिए। 
rf24 लाइब्रेरी में कुछ महत्वपूर्ण फ़ंक्शन:
begin(): वायरलेस मॉड्यूल को शुरू करता है।
setPALevel(): पावर एम्पलीफायर (PA) लेवल सेट करता है।
setDataRate(): डेटा दर सेट करता है।
openWritingPipe(): लिखने के लिए पाइप खोलता है।
openReadingPipe(): पढ़ने के लिए पाइप खोलता है।
write(): डेटा भेजता है।
read(): डेटा पढ़ता है। 
यह लाइब्रेरी nRF24L01 मॉड्यूल के साथ संचार स्थापित करने और डेटा भेजने और प्राप्त करने के लिए आवश्यक फ़ंक्शन प्रदान करती है। 
    </p1>
    <h1>spi communication about function</h1><br>
    <p1>
Arduino SPI लाइब्रेरी SPI (सीरियल पेरिफेरल इंटरफ़ेस) उपकरणों के साथ संचार की सुविधा प्रदान करती है, तथा Arduino बोर्ड को नियंत्रक के रूप में स्थापित करती है। यह लाइब्रेरी विभिन्न Arduino प्लेटफार्मों के साथ पहले से ही बंडल है, जिसमें AVR, MegaAVR, mbed, SAMD, SAM और ARC32 शामिल हैं, जिससे अलग से इंस्टॉलेशन की आवश्यकता समाप्त हो जाती है।  
Arduino SPI लाइब्रेरी के प्रमुख कार्यों और अवधारणाओं में शामिल हैं:  
SPISettings() : किसी विशेष SPI डिवाइस के साथ संचार के लिए विशिष्ट सेटिंग्स को परिभाषित करने के लिए उपयोग किया जाता है, जैसे कि क्लॉक स्पीड, डेटा मोड और बिट ऑर्डर।
शुरू करना() : SPI बस को आरंभ करता है, हार्डवेयर SPI पिन (MOSI, MISO, SCK) को कॉन्फ़िगर करता है और स्लेव सेलेक्ट (SS) पिन को आउटपुट के रूप में सेट करता है।
अंत() : SPI बस को निष्क्रिय करता है, तथा संबंधित पिनों को मुक्त करता है।
शुरुआतीट्रांसएक्शन() और एंडट्रांसएक्शन() : ये फ़ंक्शन SPI संचार को समाहित करते हैं, यह सुनिश्चित करते हुए कि परिभाषित SPISettings लागू की गई हैं और लेनदेन के दौरान बस का उचित प्रबंधन किया गया है।
सेटबिटऑर्डर() : यह निर्दिष्ट करता है कि डेटा को सबसे महत्वपूर्ण बिट (MSB) या सबसे कम महत्वपूर्ण बिट (LSB) के साथ पहले स्थानांतरित किया जाए।
सेटक्लॉकडिवाइडर() : सिस्टम क्लॉक को विभाजित करके SPI क्लॉक आवृत्ति को नियंत्रित करता है।
सेटडेटामोड() : एसपीआई मोड सेट करता है, घड़ी की ध्रुवता और चरण का निर्धारण करता है।
स्थानांतरण करना() : एसपीआई बस पर डेटा भेजने और प्राप्त करने का मुख्य कार्य। यह एक साथ एक बाइट (8 बिट) प्रेषित करता है और एक बाइट प्राप्त करता है।
हार्डवेयर SPI पिन:  
Arduino बोर्ड के लिए समर्पित हार्डवेयर SPI पिन आमतौर पर ICSP (इन-सर्किट सीरियल प्रोग्रामिंग) हेडर पर पाए जाते हैं। अधिकांश Arduino बोर्डों में MOSI, ICSP पिन 4 है, MISO, ICSP पिन 1 है, तथा SCK, ICSP पिन 3 है। जब Arduino मास्टर के रूप में कार्य करता है, तो किसी भी डिजिटल पिन को स्लेव सेलेक्ट (SS) पिन के रूप में उपयोग किया जा सकता है, लेकिन जब Arduino स्लेव के रूप में कार्य करता है, तो विशिष्ट पिन (जैसे, Uno/Duemilanove पर पिन 10, Mega पर पिन 53) को SS के रूप में उपयोग किया जाना चाहिए।  
    </p1>
    <h1>nRF24L01 librery function about</h1><br>
    <p1><br>
      
nRF24L01 Arduino लाइब्रेरी, जिसे सामान्यतः maniacbug द्वारा RF24 लाइब्रेरी कहा जाता है, nRF24L01+ वायरलेस ट्रांसीवर मॉड्यूल को नियंत्रित करने के लिए कार्यों का एक सेट प्रदान करती है। ये फ़ंक्शन डेटा के कॉन्फ़िगरेशन, ट्रांसमिशन और रिसेप्शन की अनुमति देते हैं।  
महत्वपूर्ण कार्यों:  
आरंभीकरण और विन्यास:
RF24 रेडियो (CE_PIN, CSN_PIN); : Arduino से जुड़े चिप सक्षम (CE) और चिप चयन नहीं (CSN) पिन को निर्दिष्ट करते हुए एक RF24 ऑब्जेक्ट बनाता है।
रेडियो.begin(); : रेडियो मॉड्यूल को आरंभ करता है।
रेडियो.setPALevel(RF24_PA_LOW); : पावर एम्पलीफायर (PA) स्तर सेट करता है (उदाहरण के लिए, RF24_PA_MIN , RF24_PA_LOW , RF24_PA_HIGH , RF24_PA_MAX )।
रेडियो.setDataRate(RF24_250KBPS); : डेटा दर सेट करता है (उदाहरण के लिए, RF24_250KBPS , RF24_1MBPS , RF24_2MBPS )।
रेडियो.setChannel(76); : आरएफ चैनल (0-124) सेट करता है।
रेडियो.ओपनराइटिंगपाइप(पता); : डेटा संचारित करने के लिए निर्दिष्ट 6-बाइट पते के साथ एक लेखन पाइप खोलता है।
रेडियो.ओपनरीडिंगपाइप(पाइप, पता); : निर्दिष्ट 6-बाइट पते के साथ एक विशिष्ट पाइप संख्या (0-5) पर डेटा प्राप्त करने के लिए एक रीडिंग पाइप खोलता है।
संचरण:
रेडियो.write(&data, sizeof(data)); : डेटा भेजता है. डेटा किसी भी प्रकार का हो सकता है, और sizeof(data) बाइट्स में इसका आकार निर्दिष्ट करता है ।
रेडियो.स्टॉपलिसनिंग(); : मॉड्यूल को संचारित मोड में स्विच करता है।
स्वागत समारोह:
रेडियो.स्टार्टलिसनिंग(); : मॉड्यूल को रिसीव मोड में स्विच करता है।
रेडियो.उपलब्ध(); : जाँचता है कि प्राप्त बफर से पढ़ने के लिए डेटा उपलब्ध है या नहीं। यदि डेटा उपलब्ध हो तो सत्य लौटाता है , अन्यथा असत्य लौटाता है।
radio.read(&data, sizeof(data)); : प्राप्त डेटा को निर्दिष्ट चर में पढ़ता है।
उन्नत विशेषताएँ:
radio.enableAckPayload(); : ACK पेलोड को सक्षम करता है, जिससे रिसीवर को पावती के साथ थोड़ी मात्रा में डेटा वापस भेजने की अनुमति मिलती है।
radio.writeAckPayload(pipe, &data, sizeof(data)); : किसी विशिष्ट पाइप के लिए पावती के साथ भेजे जाने वाले ACK पेलोड को लिखता है।
radio.setRetries(delay, count); : स्वचालित पुनःसंचार सेटिंग्स (पुनःप्रयासों के बीच विलंब और पुनःप्रयासों की संख्या) कॉन्फ़िगर करता है।  
यह सूची सामान्यतः प्रयुक्त कार्यों का अवलोकन प्रदान करती है; पूर्ण लाइब्रेरी सूक्ष्म नियंत्रण और डिबगिं
ग के लिए अधिक विशिष्ट कार्य प्रदान करती है।  
</p1>

 <h1>transmetor code</h1> 
 <p1>
#include /SPI.h<br>
#include nRF24L01.h<br>
#include RF24.h<br>

const uint64_t pipeOut = 0xF9E8F0F0E1LL;<br>

RF24 radio(8, 9);<br>

struct PacketData <br>
{<br>
  byte lxAxisValue;<br>
  byte lyAxisValue;<br>
  byte rxAxisValue;<br>
  byte ryAxisValue;<br>
  byte lPotValue;<br>
  byte rPotValue;<br>
  byte switch1Value;<br>
  byte switch2Value;<br>
  byte switch3Value;<br>
  byte switch4Value;<br>
}<br>
PacketData data;<br>

void setup()
{<br>
  radio.begin();<br>
  radio.setDataRate(RF24_250KBPS);<br>
  radio.openWritingPipe(pipeOut);<br>
  radio.stopListening();<br>

  pinMode(2,INPUT_PULLUP);<br>
  pinMode(3,INPUT_PULLUP);<br>
  pinMode(4,INPUT_PULLUP);<br>
  pinMode(5,INPUT_PULLUP);<br>
}<br>
void mapAndAdjustJoystickDeadBandValues(int value, boolen reverse)<br>

{<br>
  if (value >= 530)<br>
  {<br>
    value = map(value, 530, 1023, 127, 254);<br>
  }
  else if (value <= 500)<br>
  {
    value = map(value, 500, 0, 127, 0);<br>
  }<br>
  else<br>
  {<br>
    value = 127;<br>
  }<br>

  if (reverse)<br>
  {<br>
    value = 254 - value;<br>
  }<br>
  return value;<br>
}<br>


{<br>
  data.lxAxisValue    = mapAndAdjustJoystickDeadBandValues(analogRead(A0), false);<br>
  data.lyAxisValue    = mapAndAdjustJoystickDeadBandValues(analogRead(A1), false);<br>
  data.rxAxisValue    = mapAndAdjustJoystickDeadBandValues(analogRead(A2), false);<br>
  data.ryAxisValue    = mapAndAdjustJoystickDeadBandValues(analogRead(A3), false);<br>
  data.lPotValue      = map(analogRead(A4), 0, 1023, 0, 254);<br>
  data.rPotValue      = map(analogRead(A5), 0, 1023, 0, 254);<br>
  data.switch1Value   = !digitalRead(2);<br>
  data.switch2Value   = !digitalRead(3);<br>
  data.switch3Value   = !digitalRead(4);<br>
  data.switch4Value   = !digitalRead(5);<br>
        
  radio.write(&data, sizeof(PacketData));<br>
}<br>
 </p1>
 <h1>Transmitter circuit diagram</h1><br>
<img src="Transmitter.png" width="1000" height="1000"><br>
<h1>reaciver code</h1>
<p1>
#include SPI.h <br>
#include nRF24L01.h <br>
#include RF24.h<br>
#include Servo.h<br>

#define SIGNAL_TIMEOUT 500<br>

const uint64_t pipeIn = 0xF9E8F0F0E1LL;<br>
RF24 radio(8, 9);<br>
unsigned long lastRecvTime = 0;<br>

struct PacketData<br>
{<br>
  byte lxAxisValue;<br>
  byte lyAxisValue;<br>
  byte rxAxisValue;<br>
  byte ryAxisValue;<br>
  byte lPotValue;<br>
  byte rPotValue;<br>
  byte switch1Value;<br>
  byte switch2Value;<br>
  byte switch3Value;<br>
  byte switch4Value;<br>
};<br>
PacketData receiverData;<br>

Servo servo1;     //Pin D2<br>
Servo servo2;     //Pin D3<br>
Servo servo3;     //Pin D4<br>
Servo servo4;     //Pin D5<br>
Servo servo5;     //Pin D6<br>
Servo servo6;     //Pin D7<br>
int   led1 = A0;<br>
int   led2 = A1;<br>
int   led3 = A2;<br>
int   led4 = A3;<br>


void setInputDefaultValues()<br>
{<br>
  // The middle position for joystick. (254/2=127)<br>
  receiverData.lxAxisValue = 127;<br>
  receiverData.lyAxisValue = 127;<br>
  receiverData.rxAxisValue = 127;<br>
  receiverData.ryAxisValue = 127;<br>
  receiverData.lPotValue = 0;<br>
  receiverData.rPotValue = 0;<br>
  receiverData.switch1Value = LOW;<br>
  receiverData.switch2Value = LOW;<br>
  receiverData.switch3Value = LOW;<br>
  receiverData.switch4Value = LOW;<br>
}<br>

void mapAndWriteValues()<br>
{<br>
  servo1.write(map(receiverData.lxAxisValue, 0, 254, 0, 180));<br>
  servo2.write(map(receiverData.lyAxisValue, 0, 254, 0, 180));<br>
  servo3.write(map(receiverData.rxAxisValue, 0, 254, 0, 180));<br>
  servo4.write(map(receiverData.ryAxisValue, 0, 254, 0, 180));<br>
  servo5.write(map(receiverData.lPotValue, 0, 254, 0, 180));<br>
  servo6.write(map(receiverData.rPotValue, 0, 254, 0, 180));<br>
  
  digitalWrite(led1, receiverData.switch1Value);<br>
  digitalWrite(led2, receiverData.switch2Value);<br>
  digitalWrite(led3, receiverData.switch3Value);<br>
  digitalWrite(led4, receiverData.switch4Value);<br>
}<br>

void setup()<br>
{<br>
  radio.begin();<br>
  radio.setDataRate(RF24_250KBPS);<br>
  radio.openReadingPipe(1,pipeIn);<br>
  radio.startListening();<br>

  servo1.attach(2);<br>
  servo2.attach(3);<br>
  servo3.attach(4);<br>
  servo4.attach(5);<br>
  servo5.attach(6);<br>
  servo6.attach(7);<br>
  pinMode(led1, OUTPUT);<br>
  pinMode(led2, OUTPUT);<br>
  pinMode(led3, OUTPUT);<br>
  pinMode(led4, OUTPUT);<br>
 
setInputDefaultValues();<br>
   mapAndWriteValues();<br>
}  
<br>
void loop()<br>
{
  
  if(radio.isChipConnected() && radio.available())<br>
  {<br>
    radio.read(&receiverData, sizeof(PacketData));<br>
    lastRecvTime = millis();<br>
  }<br>
  else<br>
  {<br>
    
    unsigned long now = millis();<br>
    if ( now - lastRecvTime > SIGNAL_TIMEOUT )<br>
    {<br>
      setInputDefaultValues();<br>
    }<br>
  }<br>
  mapAndWriteValues();<br>
}<br>
</p1>
<h1>receiver circuit diagram </h1><br>
<img src="Receiver.png" width="1000" height="1000"><br>
<h1> video coming soon</h1>
  </body>
</html>
